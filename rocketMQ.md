#  RocketMQ











## 为什么使用MQ



1. 解耦。让多个模块系统需要的数据都直接面向消息队列，而不面某个模块服务，减少模块代码的维护工作。
2. 异步。将运行时间较长的服务或方法调用通过发送消息，让消费者模块开线程异步处理来提高系统响应速度。
3. 将数据处理的压力分散到各个功能模块，减少服务器压力。





## 为什么选择RocketMQ

1. 阿里的技术和双十一的实战经验作为支撑
2. 高吞吐量
3. 用Java语言做开发，较容易了解底层
4. RocketMQ支持分布式事务。







## 说一说RocketMQ的架构

Name Server 命名服务器。 存储主题和Broker的对应关系

**Broker**  存储消息和管理消息

生产者

消费者。





## 如何保证消息不被重复消费？如何保证消息消费时的幂等性？



1. 操作是先判断是否已经操作过了，根据实际业务判断。
2. 用Set存储需要操作的数据，保证幂等性。
3. 在消息中添加一个id标识，每次消费后都把这个标识存在redis中，并设置过期时间。每次消费的时候判断redis中是否存在这个Id，如果存在不消费。





# 如何保证消息的可靠性传输？

1. 如果生产端数据丢失，消息队列可以用事务机制进行检测，并回滚事务。
2. 因为消息队列宕机导致的数据丢失就要用持久化文件重启。
3. 消费端数据丢失，就用类似网络连接的应答机制检测。







，

