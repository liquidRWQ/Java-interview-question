# 多线程





## 什么是乐观锁，什么是悲观锁？

乐观锁是假设不会或者很少发生线程冲突设计的锁，比如CAS算法设计的锁 悲观锁是假设经常发生线程冲突设计的锁，比如synchronize



## 说一说volatile关键字的作用



volatile关键字  加在变量上，可以实现可见性有有序性。可见性是指各个线程之间对变量内存值得可见，有序性是指禁止JVM的重排序优化，使代码有序执行（happen-before） 





## 说一说volatile底层原理



​	默认情况下，线程对变量的操作是先在自身的工作内存中进行，在写入直接内存中，而volatile是通过使各人线程读写变量的操作直接在主内存中进行，实现了可见性。在操作系统层面上使用内存屏蔽来让线程在主内存中操作变量。 



## 什么是原子性

就是一些类似原子，不可分割，就是说一段操作是一个整体不可分割的操作。





## 说一说i++



i++ 的底层实际上是先从内存读取变量内容，修改，然后写回到内存中（3步），需要保证其原子性





## 说一说CAS算法



将变量预期值和内存值相比较，相同就替换，不同就自旋重试。一般是操作前先读取内存值作为预期值，修改值后准备替换时在读取内存值进行比较，相同则写入。



## CAS有什么缺点？



1.ABA问题，会发生预期值虽然和内存值一样，但是之前已经发生了其他线程多次修改内存值但是，内存值不变的情况，比如先把A改成B才改成A ，这样线程之间实时知道对方的操作，有一定的风险。解决方法，加版本变量，每次修改时递推一个版本，比较版本预期值和变量预期值来替换。



2.CAS会自旋，如果过高并发情况下容易常时间等待，导致cpu资源占用过度，会降低效率。





## ConcurrentHashMap怎么实现线程安全的？





1.7是用Segment来实现锁分段，默认分成16个段，每个段斗鱼各自独立的锁，提高并发效率。





1.8后是通过cas算法来实现线程安全。





## CopyOnWriteArrayList怎么实现线程安全的？

 

写入数据时，先复制原来的数组后，对复制后进行写入操作，原来的数组仍然能进行读取操作，写入完成后，指向原来数据的引用从新指向新的数组。





## CountDownLatch有什么用



使某一个线程等待其他线程执行完后才执行。  通过设置线程需等待的线程数，用await锁住当前线程，每单一个线程执行完成时使用countDown方法，减1，当值被减成0时，CountDownLatch锁就打开，运行该线程。





## 创建线程的方式有哪几种？



1.  实现runnable接口， 没有返回值。
2.  实现callable接口，有返回值，返回值通过泛型指定。需要和FutureTask实现类来包装进行使用。 用FutureTask对象的 get()方法获取返回值。封装的线程没执行完之前相当于用CountDownLatch锁住了当前线程，执行完后才执行该语句。
3.  继承Thread类。
4.  使用线程池创建。





## 说一说Lock如何实现等待唤醒机制





Lock使用Condition在进线程通信。用newConditon获取Condition对象。 conditon.await方法进行等待，condition.signal进行唤醒





## 说一说ReentrantReadWriteLock

对读上共享锁，对写读写互斥，对读读共享。对写上写锁，对读写互斥，对写写互斥。











## 为什么要使用线程池？



1. 降低资源消耗，重复利用线程。
2. 提高响应速度。
3. 监控和管理线程。



## 执行execute()方法和submit()方法的区别是什么呢



execute方法无返回值，submit方法有返回值，返回值通过Future来获取。



## 说一说线程池的原理



线程池是用Executor来实现的。通过线程工厂创建线程，再通过阻塞队列存放需要执行的任务。

线程池的需要设置的参数有，核心线程数，最大线程数，线程空闲存活时间，时间单元，线程工厂，阻塞队列，拒绝策略。



## 说一说有哪些阻塞队列

ArrayBlockQueue  LinkedBlockQueue   SynchronousQueue 



## 说一说线程的拒绝策略



1. Abort策略 丢弃任务，抛出异常 
2. Discard策略  丢弃任务，不抛异常
3. DiscardOldest 丢弃队列最前面的任务，加入新任务
4. Caller策略  新开一个线程进行处理任务。





## AQS的原理是什么？



AQS底层是用CLH队列和volatile修饰的状态变量实现的，CLH就是一个虚拟的双向队列，可以控制线程的等待和执行。并通过CAS算法修改状态变量来改变同步状态。





## 说一说ThreadLocal





ThreadLocal封装了一个ThreadLocalMap，以ThreadLcoal为key，变量为value进行存储。而每个Thread线程都维护了这个ThreadLocalMap的引用，从而实现了每个线程都有其专属的变量。

由于value一般是强引用，所以会发生内存泄漏问题。



###  synchronized 底层怎么实现线程安全的。



jdk1.8的sychroinized 使用了偏向锁，轻量级锁，重量级锁。



偏向锁就是相当于不加锁，轻量级锁就是使用CAS算法实现，重量级锁的话，如果使用的是synchronized代码块，是通过monitorenter和monitorexit两个字节码指令实现的，如果加在方法上的话，是通过ACC_SYNCHRONIZED这个字节码指令标志实现的，在操作系统底层上是使用操作系统的互斥锁来实现的。





## synchronized和ReentrantLock的区别

1两者都是可重入锁。



2synchronized依赖于JVM实现同步，ReentrantLock依赖于AQS。



3.ReentrantLocak更灵活。可以实现选择性通知，有公平锁，可以人为的加锁解锁。



4.在超高并发环境下，如果经常发生线程冲突，synchronized的效率会相对较高。





## 说一说happens-before原则



happens-before原则就是编译器重排序遵循的规范。

主要有

1. 一个线程的每个操作都发生在后面的操作之前。
2. 解锁要发生在加锁之前。
3. 如果两个操作的顺序改变倒是执行结果不变，就可以重排序。





## 多线程的弊端



占用过多CPU资源

